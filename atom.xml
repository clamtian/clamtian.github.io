<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>clamtian</title>
  
  <subtitle>YOU&#39;VE MADE A &lt;span&gt;BRAVE&lt;/span&gt; DECISION, WELCOME.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-01T14:12:42.987Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>clamtian</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode621：任务调度器</title>
    <link href="http://yoursite.com/2019/04/01/leetcode/"/>
    <id>http://yoursite.com/2019/04/01/leetcode/</id>
    <published>2019-04-01T14:08:27.000Z</published>
    <updated>2019-04-01T14:12:42.987Z</updated>
    
    <content type="html"><![CDATA[<p>@<a href="leetcode621：任务调度器">TOC</a></p><h2 id="先看问题："><a href="#先看问题：" class="headerlink" title="先看问题："></a>先看问题：</h2><p>给定一个用字符数组表示的 CPU 需要执行的任务列表。其中包含使用大写的 A - Z 字母表示的26 种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。</p><p>然而，两个相同种类的任务之间必须有长度为 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。</p><p>你需要计算完成所有任务所需要的最短时间。</p><p>实例1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: tasks = [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;], n = 2</span><br><span class="line">输出: 8</span><br><span class="line">执行顺序: A -&gt; B -&gt; (待命) -&gt; A -&gt; B -&gt; (待命) -&gt; A -&gt; B.</span><br></pre></td></tr></table></figure><p>注：</p><p>任务的总个数为 [1, 10000]。<br>n 的取值范围为 [0, 100]。</p><h2 id="解答思路"><a href="#解答思路" class="headerlink" title="解答思路"></a>解答思路</h2><p>首先看到“大写的A-Z”时，我就想到应该可以用大小为26的数组来充当辅助数组，但之后却没有一个良好完整的思路，纠结无果后，去网上找了题解来看，这里来记录一下这道题，以供自己日后温习。<br>以 [“A”,”A”,”A”,”A”,”B”,”B”,”B”,”B”,”C”,”C”,”C”,”D”,”D”,”E”]，n = 2，为例来进行说明。<br>首先用26大小数组来确定每个任务的数量，然后将数组进行排序，将数量最大的排到最后。由于任务是交替执行的，数量最多的任务必然应该安排到每个n的节点上以求达到最短时间，如图（其中“#”代表除A以外的其他字符）：<br>|A|#|#|A|#|#|A|#|#|A|#|…<br>|–|–|–|–|–|–|–|–|–|–|–|–|<br>这时可以看到ans至少等于（A的数量-1）*（n + 1）+ 1，其它数量小于等于A的字符就可以被安插在“#”的位置。这时数量等于A的字符必然会占到最后一个A后面“#”的位置，如下图的B，这时ans的数量就要加一：<br>|A|C|#|A|C|#|A|C|#|A|C|…<br>|–|–|–|–|–|–|–|–|–|–|–|–|</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int leastInterval(char[] tasks, int n) &#123;</span><br><span class="line">        int len = tasks.length;</span><br><span class="line">        if(len &lt; 1 || n &lt; 0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] nums = new int[26];</span><br><span class="line">        int i = 0;</span><br><span class="line">        //得到每个字符的数量后再排序</span><br><span class="line">        while(i &lt; len)&#123;</span><br><span class="line">            nums[tasks[i++] - 65]++;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        //res的最小值</span><br><span class="line">        int res = (nums[25] - 1) * (n + 1);</span><br><span class="line">        i = 25;</span><br><span class="line">        while(i &gt;= 0 &amp;&amp; nums[i] == nums[25])&#123;</span><br><span class="line">    //若最多数量的字符有多个 则res相应地+1</span><br><span class="line">            res++;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        //得到的结果为res与数组长度len之间最大值</span><br><span class="line">        return res &gt; len ? res : len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;@&lt;a href=&quot;leetcode621：任务调度器&quot;&gt;TOC&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;先看问题：&quot;&gt;&lt;a href=&quot;#先看问题：&quot; class=&quot;headerlink&quot; title=&quot;先看问题：&quot;&gt;&lt;/a&gt;先看问题：&lt;/h2&gt;&lt;p&gt;给定一个用字符数组表示的 C
      
    
    </summary>
    
      <category term="leetcode题解" scheme="http://yoursite.com/categories/leetcode%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
</feed>
