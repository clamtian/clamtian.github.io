<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[FDTD讲解_1]]></title>
    <url>%2F2020%2F09%2F29%2FFDTD_1%2F</url>
    <content type="text"><![CDATA[要彻底弄懂FDTD，首先就要从基本的麦克斯韦方程组出发，一步步推导至我们编程需要的公式。典型的时域麦克斯韦方程组如下： \begin{cases} \frac {\partial H_z}{\partial y}-\frac {\partial H_y}{\partial z}=\epsilon\frac {\partial E_x}{\partial t}+\sigma E_x\\[2ex] \frac {\partial H_x}{\partial z}-\frac {\partial H_z}{\partial x}=\epsilon\frac {\partial E_y}{\partial t}+\sigma E_y\\[2ex] \frac {\partial H_y}{\partial x}-\frac {\partial H_x}{\partial y}=\epsilon\frac {\partial E_z}{\partial t}+\sigma E_z \end{cases}以及 \begin{cases} \frac {\partial E_z}{\partial y}-\frac {\partial E_y}{\partial z}=-\mu\frac {\partial H_x}{\partial t}-\sigma_m H_x\\[2ex] \frac {\partial E_x}{\partial z}-\frac {\partial E_z}{\partial x}=-\mu\frac {\partial H_y}{\partial t}-\sigma_m H_y\\[2ex] \frac {\partial E_y}{\partial x}-\frac {\partial E_x}{\partial y}=-\mu\frac {\partial H_z}{\partial t}-\sigma_m H_z \end{cases}为了后续推导的方便，我们首先定义 f(x, y, z, t) = f(i\Delta x, j\Delta y, k\Delta z, n\Delta t)=f^n(i, j, k)然后对麦克斯韦方程组中的一节偏导数取中心差分近似，有 \begin{cases} \frac {\partial f(x, y, z, t)}{\partial x}|_{x=i\Delta x}\approx \frac { f^n(i+1/2, j, k) - f^n(i-1/2, j, k)}{\Delta x}\\[2ex] \frac {\partial f(x, y, z, t)}{\partial y}|_{x=j\Delta y}\approx \frac { f^n(i, j + 1/2, k) - f^n(i, j - 1/2, k)}{\Delta y}\\[2ex] \frac {\partial f(x, y, z, t)}{\partial z}|_{x=k\Delta z}\approx \frac { f^n(i, j, k + 1/2) - f^n(i, j, k - 1/2)}{\Delta z}\\[2ex] \frac {\partial f(x, y, z, t)}{\partial t}|_{x=n\Delta t}\approx \frac { f^{n + 1/2}(i, j, k) - f^{n - 1/2}(i, j, k)}{\Delta t} \end{cases}然后便可以得到著名的Yee元胞： 由上述推导以及Yee元胞中可以看到，在FDTD中电场与磁场的采样位置和采样时间皆相差半个步长。如此，当给定电磁问题的初始值以及边界条件后，便可以根据差分公式一步步地推导空间任意点处的电场与磁场。下面便是根据差分公式推导出的麦克斯韦方程组的FDTD形式（无耗各向同性媒质中）： \begin{cases} {E^{n + 1}_{x}(i + 1/2, j, k)} = CA \cdot {E^{n}_{x}(i + 1/2, j, k)} + CB \cdot \left [ \frac { H^{n + 1/2}_z(i + 1/2, j + 1/2, k) - H^{n + 1/2}_z(i + 1/2, j - 1/2, k)}{\Delta y} - \frac { H^{n + 1/2}_y(i + 1/2, j, k + 1/2) - H^{n + 1/2}_y(i + 1/2, j, k - 1/2)}{\Delta z} \right ] \\[2ex] {E^{n + 1}_{y}(i, j + 1/2, k)} = CA \cdot {E^{n}_{y}(i, j + 1/2, k)} + CB \cdot \left [ \frac { H^{n + 1/2}_x(i, j + 1/2, k + 1/2) - H^{n + 1/2}_x(i, j + 1/2, k - 1/2)}{\Delta z} - \frac { H^{n + 1/2}_z(i + 1/2, j + 1/2, k) - H^{n + 1/2}_z(i - 1/2, j + 1/2, k)}{\Delta x} \right ] \\[2ex] {E^{n + 1}_{z}(i, j, k + 1/2)} = CA \cdot {E^{n}_{z}(i, j, k + 1/2)} + CB \cdot \left [ \frac { H^{n + 1/2}_y(i + 1/2, j, k + 1/2) - H^{n + 1/2}_y(i - 1/2, j, k + 1/2)}{\Delta x} - \frac { H^{n + 1/2}_x(i, j + 1/2, k + 1/2) - H^{n + 1/2}_x(i, j - 1/2, k + 1/2)}{\Delta y} \right ] \end{cases}以及 \begin{cases} {H^{n + 1/2}_{x}(i, j + 1/2, k + 1/2)} = CP \cdot {H^{n - 1/2}_{x}(i, j + 1/2, k + 1/2)} - CQ \cdot \left [ \frac { E^{n}_z(i, j + 1, k + 1/2) - E^{n}_z(i, j, k + 1/2)}{\Delta y} - \frac { E^{n}_y(i, j + 1/2, k + 1) - E^{n}_y(i, j + 1/2, k)}{\Delta z} \right ] \\[2ex] {H^{n + 1/2}_{y}(i + 1/2, j, k + 1/2)} = CP \cdot {H^{n - 1/2}_{y}(i + 1/2, j, k + 1/2)} - CQ \cdot \left [ \frac { E^{n}_x(i + 1/2, j, k + 1) - E^{n}_x(i + 1/2, j, k)}{\Delta z} - \frac { E^{n}_z(i + 1, j, k + 1/2) - E^{n}_z(i, j, k + 1/2)}{\Delta x} \right ] \\[2ex] {H^{n + 1/2}_{z}(i + 1/2, j + 1/2, k)} = CP \cdot {H^{n - 1/2}_{z}(i + 1/2, j + 1/2, k)} - CQ \cdot \left [ \frac { E^{n}_y(i + 1, j + 1/2, k) - E^{n}_y(i, j + 1/2, k)}{\Delta x} - \frac { E^{n}_x(i + 1/2, j + 1, k) - E^{n}_x(i + 1/2, j, k)}{\Delta y} \right ] \end{cases}上式中 CA = \frac {\frac {\epsilon}{\Delta t} - \frac {\sigma}{2}}{\frac {\epsilon}{\Delta t} + \frac {\sigma}{2}} = \frac {1 - \frac {\sigma \Delta t}{2 \epsilon}}{1 + \frac {\sigma \Delta t}{2 \epsilon}}CB = \frac {1}{\frac {\epsilon}{\Delta t} + \frac {\sigma}{2}} = \frac {\frac {\Delta t}{\epsilon}}{1 + \frac {\sigma \Delta t}{2 \epsilon}}CP = \frac {\frac {\mu}{\Delta t} - \frac {\sigma_m}{2}}{\frac {\mu}{\Delta t} + \frac {\sigma_m}{2}} = \frac {1 - \frac {\sigma_m \Delta t}{2 \mu}}{1 + \frac {\sigma_m \Delta t}{2 \mu}}CB = \frac {1}{\frac {\mu}{\Delta t} + \frac {\sigma_m}{2}} = \frac {\frac {\Delta t}{\mu}}{1 + \frac {\sigma_m \Delta t}{2 \mu}}接下来讲解具体的编程思路，在上述FDTD公式中包含很多“半步长”的式子，而这些“半步长”的公式在C++中是比较难直接实现的。所以为了简化编程的复杂度，我们把这些“半步长”阉割掉，同时六个节点都用相同的整数步长。牢记，对任意给定的一组整数步长，电场节点向其所指的方向移动半个步长，磁场节点向其未指的方向移动半个步长，例如FDTD的电场公式： \begin{cases} {E^{n + 1}_{x}(i + 1/2, j, k)} = CA \cdot {E^{n}_{x}(i + 1/2, j, k)} + CB \cdot \left [ \frac { H^{n + 1/2}_z(i + 1/2, j + 1/2, k) - H^{n + 1/2}_z(i + 1/2, j - 1/2, k)}{\Delta y} - \frac { H^{n + 1/2}_y(i + 1/2, j, k + 1/2) - H^{n + 1/2}_y(i + 1/2, j, k - 1/2)}{\Delta z} \right ] \\[2ex] {E^{n + 1}_{y}(i, j + 1/2, k)} = CA \cdot {E^{n}_{y}(i, j + 1/2, k)} + CB \cdot \left [ \frac { H^{n + 1/2}_x(i, j + 1/2, k + 1/2) - H^{n + 1/2}_x(i, j + 1/2, k - 1/2)}{\Delta z} - \frac { H^{n + 1/2}_z(i + 1/2, j + 1/2, k) - H^{n + 1/2}_z(i - 1/2, j + 1/2, k)}{\Delta x} \right ] \\[2ex] {E^{n + 1}_{z}(i, j, k + 1/2)} = CA \cdot {E^{n}_{z}(i, j, k + 1/2)} + CB \cdot \left [ \frac { H^{n + 1/2}_y(i + 1/2, j, k + 1/2) - H^{n + 1/2}_y(i - 1/2, j, k + 1/2)}{\Delta x} - \frac { H^{n + 1/2}_x(i, j + 1/2, k + 1/2) - H^{n + 1/2}_x(i, j - 1/2, k + 1/2)}{\Delta y} \right ] \end{cases}在实际编程时实现时，我们会把它简化成： \begin{cases} {E^{n + 1}_{x}(i, j, k)} = CA \cdot {E^{n}_{x}(i, j, k)} + CB \cdot \left [ \frac { H^{n}_z(i, j, k) - H^{n}_z(i, j - 1, k)}{\Delta y} - \frac { H^{n}_y(i, j, k) - H^{n}_y(i, j, k - 1)}{\Delta z} \right ] \\[2ex] {E^{n + 1}_{y}(i, j, k)} = CA \cdot {E^{n}_{y}(i, j, k)} + CB \cdot \left [ \frac { H^{n}_x(i, j, k) - H^{n}_x(i, j, k - 1)}{\Delta z} - \frac { H^{n}_z(i, j, k) - H^{n}_z(i - 1, j, k)}{\Delta x} \right ] \\[2ex] {E^{n + 1}_{z}(i, j, k)} = CA \cdot {E^{n}_{z}(i, j, k)} + CB \cdot \left [ \frac { H^{n}_y(i, j, k) - H^{n}_y(i - 1, j, k)}{\Delta x} - \frac { H^{n}_x(i, j, k) - H^{n}_x(i, j - 1, k)}{\Delta y} \right ] \end{cases}磁场的FDTD则简化为： \begin{cases} {H^{n + 1}_{x}(i, j, k)} = CP \cdot {H^{n}_{x}(i, j, k)} - CQ \cdot \left [ \frac { E^{n + 1}_z(i, j + 1, k) - E^{n + 1}_z(i, j, k)}{\Delta y} - \frac { E^{n + 1}_y(i, j, k + 1) - E^{n + 1}_y(i, j, k)}{\Delta z} \right ] \\[2ex] {H^{n + 1}_{y}(i, j, k)} = CP \cdot {H^{n}_{y}(i, j, k)} - CQ \cdot \left [ \frac { E^{n + 1}_x(i, j, k + 1) - E^{n + 1}_x(i, j, k)}{\Delta z} - \frac { E^{n + 1}_z(i + 1, j, k) - E^{n + 1}_z(i, j, k)}{\Delta x} \right ] \\[2ex] {H^{n + 1}_{z}(i, j, k)} = CP \cdot {H^{n}_{z}(i, j, k)} - CQ \cdot \left [ \frac { E^{n + 1}_y(i + 1, j, k) - E^{n + 1}_y(i, j, k)}{\Delta x} - \frac { E^{n + 1}_x(i, j + 1, k) - E^{n + 1}_x(i, j, k)}{\Delta y} \right ] \end{cases}注意，上式中的$H^n$和$E^n$是相差半个时间步长的，如下图：这样，磁场和电场就可以随着时间交替求解。我用C++实现了上述过程，点击此处查看。]]></content>
      <categories>
        <category>FDTD</category>
      </categories>
      <tags>
        <tag>计算电磁</tag>
        <tag>算法</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode714：买卖股票的最佳时机含手续费]]></title>
    <url>%2F2019%2F04%2F02%2Fleetcode714%EF%BC%9A%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9%2F</url>
    <content type="text"><![CDATA[先看问题给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。 你可以无限次地完成交易，但是你每次交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。 返回获得利润的最大值。 实例1： 12345678输入: prices = [1, 3, 2, 8, 4, 9], fee = 2输出: 8解释: 能够达到的最大利润: 在此处买入 prices[0] = 1在此处卖出 prices[3] = 8在此处买入 prices[4] = 4在此处卖出 prices[5] = 9总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8. 注意: 0 &lt; prices.length &lt;= 50000. 0 &lt; prices[i] &lt; 50000. 0 &lt;= fee &lt; 50000. 问题分析 典型的dp问题，可用标准的dp公式解决。 创建两个数组have和noHave，hava[i]表示第i天持有股票时的最大收益，noHave[i]表示第i天不持有股票时的最大收益。 可以得到dp公式： ​ have[i] = max(have[i], noHave[i] - prices[i]) ​ noHave[i] = max(have[i] + prices[i] - fee, noHave[i]) noHave[len - 1]即为此数组的最大收益。 代码1234567891011121314151617181920class Solution &#123; public int maxProfit(int[] prices, int fee) &#123; int len = prices.length; if(len == 1)&#123; return 0; &#125; //dp1[i]代表第i天持有股票 //dp2[i]代表第i天未持有股票 int[] dp1 = new int[len]; int[] dp2 = new int[len]; dp1[0] = -prices[0]; int i = 1; while(i &lt; len)&#123; dp1[i] = Math.max(dp1[i - 1],dp2[i - 1] - prices[i]); dp2[i] = Math.max(dp1[i - 1] + prices[i] - fee,dp2[i - 1]); i++; &#125; return dp2[len - 1]; &#125;&#125; 由于整个过程只使用到dp1[i]、dp1[i - 1]、dp2[i]和dp2[i -1]，所以其实可以使用四个变量来代替数组，使得空间复杂度达到O(1)。 123456789101112131415161718192021class Solution &#123; public int maxProfit(int[] prices, int fee) &#123; int len = prices.length; if(len == 1)&#123; return 0; &#125; int d1 = -prices[0]; int d2 = 0;; int p1 = 0; int p2 = 0;; int i = 1; while(i &lt; len)&#123; d2 = Math.max(d1,p1 - prices[i]); p2 = Math.max(d1 + prices[i] - fee,p1); p1 = p2; d1 = d2; i++; &#125; return p2; &#125;&#125; 运行结果]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>leetcode 算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode621：任务调度器]]></title>
    <url>%2F2019%2F04%2F01%2Fleetcode621%EF%BC%9A%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8%2F</url>
    <content type="text"><![CDATA[先看问题：给定一个用字符数组表示的 CPU 需要执行的任务列表。其中包含使用大写的 A - Z 字母表示的26 种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。 然而，两个相同种类的任务之间必须有长度为 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。 你需要计算完成所有任务所需要的最短时间。 实例1： 123输入: tasks = [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;], n = 2输出: 8执行顺序: A -&gt; B -&gt; (待命) -&gt; A -&gt; B -&gt; (待命) -&gt; A -&gt; B. 注： 任务的总个数为 [1, 10000]。n 的取值范围为 [0, 100]。 解答思路首先看到“大写的A-Z”时，我就想到应该可以用大小为26的数组来充当辅助数组，但之后却没有一个良好完整的思路，纠结无果后，去网上找了题解来看，这里来记录一下这道题，以供自己日后温习。以 [“A”,”A”,”A”,”A”,”B”,”B”,”B”,”B”,”C”,”C”,”C”,”D”,”D”,”E”]，n = 2，为例来进行说明。首先用26大小数组来确定每个任务的数量，然后将数组进行排序，将数量最大的排到最后。由于任务是交替执行的，数量最多的任务必然应该安排到每个n的节点上以求达到最短时间，如图（其中“#”代表除A以外的其他字符）： A # # A # # A # # A # … 这时可以看到ans至少等于（A的数量-1）*（n + 1）+ 1，其它数量小于等于A的字符就可以被安插在“#”的位置。这时数量等于A的字符必然会占到最后一个A后面“#”的位置，如下图的B，这时ans的数量就要加一： A C # A C # A C # A C … 代码：12345678910111213141516171819202122232425class Solution &#123; public int leastInterval(char[] tasks, int n) &#123; int len = tasks.length; if(len &lt; 1 || n &lt; 0)&#123; return 0; &#125; int[] nums = new int[26]; int i = 0; //得到每个字符的数量后再排序 while(i &lt; len)&#123; nums[tasks[i++] - 65]++; &#125; Arrays.sort(nums); //res的最小值 int res = (nums[25] - 1) * (n + 1); i = 25; while(i &gt;= 0 &amp;&amp; nums[i] == nums[25])&#123; //若最多数量的字符有多个 则res相应地+1 res++; i--; &#125; //得到的结果为res与数组长度len之间最大值 return res &gt; len ? res : len; &#125;&#125; 运行结果]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
</search>
